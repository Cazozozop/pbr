<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Convertisseur PBR</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #eee; padding: 20px; }
    input, button, select { margin: 5px 0; }
    canvas { image-rendering: pixelated; }
    .preview { display: flex; gap: 10px; margin: 10px 0; }
    .bar { width: 100%; height: 10px; background: #444; margin: 10px 0; }
    .fill { height: 100%; width: 0%; background: #0f0; }
  </style>
</head>
<body>
  <h2>üñºÔ∏è Convertisseur PBR avec relief</h2>

  <input type="file" id="zipInput" accept=".zip" />
  <div class="bar"><div id="progressBar" class="fill"></div></div>

  <button id="startBtn" disabled>Commencer la conversion</button>

  <div>
    <label>Direction de la lumi√®re (angle¬∞)</label><br>
    <input type="range" id="lightDir" min="0" max="360" value="45">
  </div>

  <div>
    <label>Intensit√© du relief</label><br>
    <input type="range" id="depth" min="-10" max="10" value="0">
  </div>

  <div>
    <label>Couleur de la lumi√®re</label><br>
    <input type="color" id="lightColor" value="#ffffff">
  </div>

  <div>
    <label>Transparence lumi√®re (%)</label><br>
    <input type="range" id="lightAlpha" min="0" max="50" value="0">
  </div>

  <h3>üîç Aper√ßu avant-apr√®s</h3>
  <div class="preview">
    <img src="https://i.imgur.com/tGbaZCY.png" width="128" height="128" style="background:#000">
    <canvas id="previewCanvas" width="128" height="128" style="background:#000"></canvas>
  </div>

  <button id="downloadModified" disabled>T√©l√©charger images PBR</button>
  <button id="downloadOriginals" disabled>T√©l√©charger normal maps seules</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    const zipInput = document.getElementById('zipInput');
    const progressBar = document.getElementById('progressBar');
    const previewCanvas = document.getElementById('previewCanvas');
    const ctx = previewCanvas.getContext('2d');
    let originalImages = [];
    let pbrImages = [];
    let normalsOnly = [];

    const getRelief = (img, angleDeg, depth, lightCol, alpha) => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      const src = ctx.getImageData(0, 0, img.width, img.height);
      const dst = ctx.createImageData(src);
      const a = (angleDeg * Math.PI) / 180;
      const lx = Math.cos(a), ly = Math.sin(a);

      for (let y = 1; y < img.height - 1; y++) {
        for (let x = 1; x < img.width - 1; x++) {
          const i = (y * img.width + x) * 4;
          const gx = ((src.data[i - 4] & 0xff) - (src.data[i + 4] & 0xff)) * depth;
          const gy = ((src.data[i - img.width * 4] & 0xff) - (src.data[i + img.width * 4] & 0xff)) * depth;
          let light = 128 + gx * lx + gy * ly;
          light = Math.min(255, Math.max(0, light));

          dst.data[i] = (src.data[i] + lightCol[0] * light / 255) / 2;
          dst.data[i + 1] = (src.data[i + 1] + lightCol[1] * light / 255) / 2;
          dst.data[i + 2] = (src.data[i + 2] + lightCol[2] * light / 255) / 2;
          dst.data[i + 3] = Math.max(0, src.data[i + 3] - alpha * 5);
        }
      }

      ctx.putImageData(dst, 0, 0);
      return canvas;
    };

    zipInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const zip = await JSZip.loadAsync(file);
      let files = Object.values(zip.files).filter(f => /\.(png|jpg|jpeg)$/i.test(f.name));
      progressBar.style.width = "0%";
      let done = 0;
      originalImages = [];

      for (let f of files) {
        const blob = await f.async("blob");
        const img = new Image();
        const url = URL.createObjectURL(blob);
        await new Promise(res => {
          img.onload = () => {
            originalImages.push({ name: f.name, img });
            URL.revokeObjectURL(url);
            progressBar.style.width = `${++done / files.length * 100}%`;
            res();
          };
          img.src = url;
        });
      }
      document.getElementById("startBtn").disabled = false;
    });

    document.getElementById("startBtn").onclick = async () => {
      const angle = +document.getElementById("lightDir").value;
      const depth = +document.getElementById("depth").value;
      const color = document.getElementById("lightColor").value;
      const alpha = +document.getElementById("lightAlpha").value;
      const rgb = color.match(/\w\w/g).map(x => parseInt(x, 16));

      pbrImages = [];
      normalsOnly = [];

      for (let { name, img } of originalImages) {
        const canvas = getRelief(img, angle, depth, rgb, alpha);
        pbrImages.push({ name, canvas });

        const normalMap = document.createElement("canvas");
        normalMap.width = img.width;
        normalMap.height = img.height;
        const nctx = normalMap.getContext("2d");
        nctx.filter = `contrast(200%) grayscale(100%) brightness(${100 + depth * 5}%)`;
        nctx.drawImage(img, 0, 0);
        normalsOnly.push({ name, canvas: normalMap });
      }

      // Mettre preview
      ctx.clearRect(0, 0, 128, 128);
      ctx.drawImage(pbrImages[0].canvas, 0, 0, 128, 128);

      document.getElementById("downloadModified").disabled = false;
      document.getElementById("downloadOriginals").disabled = false;
    };

    document.getElementById("downloadModified").onclick = () => {
      const zip = new JSZip();
      for (let { name, canvas } of pbrImages)
        zip.file(name, canvas.toDataURL().split(",")[1], { base64: true });
      zip.generateAsync({ type: "blob" }).then(b => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(b);
        a.download = "images_PBR.zip";
        a.click();
      });
    };

    document.getElementById("downloadOriginals").onclick = () => {
      const zip = new JSZip();
      for (let { name, canvas } of normalsOnly)
        zip.file("normal_" + name, canvas.toDataURL().split(",")[1], { base64: true });
      zip.generateAsync({ type: "blob" }).then(b => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(b);
        a.download = "normal_maps.zip";
        a.click();
      });
    };
  </script>
</body>
</html>
