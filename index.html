<!DOCTYPE html>
<html lang="fr">
<head>
Â  <meta charset="UTF-8">
Â  <title>Convertisseur PBR visuel (relief)</title>
Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
Â  <style>
Â  Â  body {
Â  Â  Â  background: #111;
Â  Â  Â  color: white;
Â  Â  Â  font-family: sans-serif;
Â  Â  Â  text-align: center;
Â  Â  Â  padding: 20px;
Â  Â  }
Â  Â  input[type="range"] {
Â  Â  Â  width: 50%;
Â  Â  }
Â  Â  .controls {
Â  Â  Â  display: none; /* Hidden until files are uploaded */
Â  Â  Â  margin-top: 20px;
Â  Â  Â  border: 1px solid #333;
Â  Â  Â  padding: 15px;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  max-width: 800px;
Â  Â  Â  margin-left: auto;
Â  Â  Â  margin-right: auto;
Â  Â  }
Â  Â  .preview-container {
Â  Â  Â  display: flex;
Â  Â  Â  justify-content: space-around;
Â  Â  Â  margin-top: 20px;
Â  Â  }
Â  Â  .preview-box {
Â  Â  Â  border: 1px solid #444;
Â  Â  Â  padding: 10px;
Â  Â  Â  border-radius: 5px;
Â  Â  }
Â  </style>
</head>
<body>
Â  <h1>ğŸ–¼ï¸ Convertisseur PBR visuel (relief appliquÃ©)</h1>
Â  <input type="file" id="input" multiple accept=".zip,image/*"><br><br>
Â  <button id="uploadBtn">â¬†ï¸ Uploader les images</button><br><br>

Â  <progress id="uploadProgress" value="0" max="1" style="width:70%;display:none;"></progress><br><br>

Â  <div id="conversionControls" class="controls">
Â  Â  <h2>ParamÃ¨tres de Conversion</h2>
Â  Â  ---
Â  Â  <h3>Direction de la LumiÃ¨re</h3>
Â  Â  <div>
Â  Â  Â  <label><input type="radio" name="lightDir" value="top-left" checked> Haut-Gauche</label>
Â  Â  Â  <label><input type="radio" name="lightDir" value="top"> Haut</label>
Â  Â  Â  <label><input type="radio" name="lightDir" value="top-right"> Haut-Droite</label>
Â  Â  Â  Â  Â  </div><br>

Â  Â  <h3>Puissance du Relief</h3>
Â  Â  <input type="range" id="reliefPower" min="-10" max="10" value="0" step="0.1"><br><br>

Â  Â  <h3>Couleur de la LumiÃ¨re</h3>
Â  Â  <input type="color" id="lightColor" value="#FFFFFF"><br><br>

Â  Â  <h3>Transparence de la LumiÃ¨re</h3>
Â  Â  <input type="range" id="lightTransparency" min="0" max="50" value="0" step="1"><br><br>
Â  Â  ---
Â  Â  <button id="start">âš™ï¸ Commencer la conversion</button><br><br>
Â  </div>

Â  <progress id="conversionProgress" value="0" max="1" style="width:70%;display:none;"></progress><br><br>

Â  <div class="preview-container">
Â  Â  <div class="preview-box">
Â  Â  Â  <h3>Original (Agrandie, PixÃ©lisÃ©e)</h3>
Â  Â  Â  <canvas id="originalPreview" width="200" height="200" style="border:1px solid #555;"></canvas>
Â  Â  </div>
Â  Â  <div class="preview-box">
Â  Â  Â  <h3>Avec Relief</h3>
Â  Â  Â  <canvas id="reliefPreview" width="200" height="200" style="border:1px solid #555;"></canvas>
Â  Â  </div>
Â  </div><br>

Â  <button id="download-original" disabled>ğŸ“¥ TÃ©lÃ©charger images agrandies</button>
Â  <button id="download-relief" disabled>ğŸ“¥ TÃ©lÃ©charger images avec relief</button>

Â  <script>
Â  Â  const input = document.getElementById("input");
Â  Â  const uploadBtn = document.getElementById("uploadBtn");
Â  Â  const uploadProgress = document.getElementById("uploadProgress");
Â  Â  const conversionControls = document.getElementById("conversionControls");
Â  Â  const startBtn = document.getElementById("start");
Â  Â  const conversionProgress = document.getElementById("conversionProgress");
Â  Â  const btnOriginal = document.getElementById("download-original");
Â  Â  const btnRelief = document.getElementById("download-relief");

Â  Â  const reliefPowerSlider = document.getElementById("reliefPower");
Â  Â  const lightColorPicker = document.getElementById("lightColor");
Â  Â  const lightTransparencySlider = document.getElementById("lightTransparency");
Â  Â  const lightDirectionRadios = document.querySelectorAll('input[name="lightDir"]');

Â  Â  const originalPreviewCanvas = document.getElementById("originalPreview");
Â  Â  const reliefPreviewCanvas = document.getElementById("reliefPreview");
Â  Â  const originalPreviewCtx = originalPreviewCanvas.getContext("2d");
Â  Â  const reliefPreviewCtx = reliefPreviewCanvas.getContext("2d");

Â  Â  let uploadedFiles = [];
Â  Â  let currentPreviewImage = null; // Store the currently displayed preview image

Â  Â  // Helper functions (upscale, getLum, normalize remain the same)
Â  Â  function upscale(img, scale = 4) {
Â  Â  Â  const canvas = document.createElement("canvas");
Â  Â  Â  canvas.width = img.width * scale;
Â  Â  Â  canvas.height = img.height * scale;
Â  Â  Â  const ctx = canvas.getContext("2d");
Â  Â  Â  ctx.imageSmoothingEnabled = false;
Â  Â  Â  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
Â  Â  Â  return canvas;
Â  Â  }

Â  Â  function getLum(data, x, y, w) {
Â  Â  Â  const i = (y * w + x) * 4;
Â  Â  Â  return (data[i] + data[i+1] + data[i+2]) / 3 / 255;
Â  Â  }

Â  Â  function normalize(v) {
Â  Â  Â  const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
Â  Â  Â  return [v[0]/len, v[1]/len, v[2]/len];
Â  Â  }

Â  Â  function hexToRgb(hex) {
Â  Â  Â  const bigint = parseInt(hex.slice(1), 16);
Â  Â  Â  const r = (bigint >> 16) & 255;
Â  Â  Â  const g = (bigint >> 8) & 255;
Â  Â  Â  const b = bigint & 255;
Â  Â  Â  return [r, g, b];
Â  Â  }

Â  Â  function generateNormalMap(canvas, reliefStrength = 1) {
Â  Â  Â  const w = canvas.width, h = canvas.height;
Â  Â  Â  const ctx = canvas.getContext("2d");
Â  Â  Â  const src = ctx.getImageData(0, 0, w, h);
Â  Â  Â  const dst = ctx.createImageData(w, h);

Â  Â  Â  for (let y = 1; y < h - 1; y++) {
Â  Â  Â  Â  for (let x = 1; x < w - 1; x++) {
Â  Â  Â  Â  Â  const i = (y * w + x) * 4;
Â  Â  Â  Â  Â  const alpha = src.data[i+3];
Â  Â  Â  Â  Â  if (alpha < 10) {
Â  Â  Â  Â  Â  Â  dst.data.set([0,0,0,0], i);
Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // Apply reliefStrength to dx and dy
Â  Â  Â  Â  Â  const dx = (getLum(src.data, x+1, y, w) - getLum(src.data, x-1, y, w)) * reliefStrength;
Â  Â  Â  Â  Â  const dy = (getLum(src.data, x, y+1, w) - getLum(src.data, x, y-1, w)) * reliefStrength;
Â  Â  Â  Â  Â  const dz = 1; // Z component remains constant for a height map based normal map
Â  Â  Â  Â  Â  const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
Â  Â  Â  Â  Â  const nx = dx/len, ny = dy/len, nz = dz/len;

Â  Â  Â  Â  Â  dst.data[i] = (nx * 0.5 + 0.5) * 255;
Â  Â  Â  Â  Â  dst.data[i+1] = (ny * 0.5 + 0.5) * 255;
Â  Â  Â  Â  Â  dst.data[i+2] = (nz * 0.5 + 0.5) * 255;
Â  Â  Â  Â  Â  dst.data[i+3] = alpha;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return dst;
Â  Â  }

Â  Â  function applyLighting(canvas, normalMapData, lightDir, lightColor, lightTransparency) {
Â  Â  Â  const w = canvas.width, h = canvas.height;
Â  Â  Â  const light = normalize(lightDir);
Â  Â  Â  const [lr, lg, lb] = lightColor; // RGB components of light color

Â  Â  Â  const offCanvas = document.createElement("canvas");
Â  Â  Â  offCanvas.width = w;
Â  Â  Â  offCanvas.height = h;
Â  Â  Â  const offCtx = offCanvas.getContext("2d");
Â  Â  Â  offCtx.drawImage(canvas, 0, 0);
Â  Â  Â  const imgData = offCtx.getImageData(0, 0, w, h);

Â  Â  Â  const transparencyFactor = (100 - lightTransparency) / 100; // 0 to 1, 1 being fully transparent (original color)

Â  Â  Â  for (let i = 0; i < imgData.data.length; i += 4) {
Â  Â  Â  Â  const r = normalMapData.data[i];
Â  Â  Â  Â  const g = normalMapData.data[i + 1];
Â  Â  Â  Â  const b = normalMapData.data[i + 2];
Â  Â  Â  Â  const a = normalMapData.data[i + 3];

Â  Â  Â  Â  if (a < 10) continue;

Â  Â  Â  Â  const nx = r / 255 * 2 - 1;
Â  Â  Â  Â  const ny = g / 255 * 2 - 1;
Â  Â  Â  Â  const nz = b / 255 * 2 - 1;

Â  Â  Â  Â  const dot = Math.max(0, nx * light[0] + ny * light[1] + nz * light[2]); // Max 0 ensures no negative light

Â  Â  Â  Â  // Calculate ambient light (e.g., 20% of full light)
Â  Â  Â  Â  const ambient = 0.2;
Â  Â  Â  Â  const finalLightIntensity = Math.min(1, dot + ambient); // Clamp to 1

Â  Â  Â  Â  // Apply light color
Â  Â  Â  Â  const litR = imgData.data[i] * finalLightIntensity * (lr / 255);
Â  Â  Â  Â  const litG = imgData.data[i+1] * finalLightIntensity * (lg / 255);
Â  Â  Â  Â  const litB = imgData.data[i+2] * finalLightIntensity * (lb / 255);

Â  Â  Â  Â  // Blend with original color based on transparency
Â  Â  Â  Â  imgData.data[i] = imgData.data[i] * transparencyFactor + litR * (1 - transparencyFactor);
Â  Â  Â  Â  imgData.data[i+1] = imgData.data[i+1] * transparencyFactor + litG * (1 - transparencyFactor);
Â  Â  Â  Â  imgData.data[i+2] = imgData.data[i+2] * transparencyFactor + litB * (1 - transparencyFactor);
Â  Â  Â  }

Â  Â  Â  offCtx.putImageData(imgData, 0, 0);
Â  Â  Â  return offCanvas;
Â  Â  }

Â  Â  async function extractFiles(fileList) {
Â  Â  Â  let images = [];
Â  Â  Â  let loadedCount = 0;
Â  Â  Â  const totalFiles = fileList.length;

Â  Â  Â  for (const file of fileList) {
Â  Â  Â  Â  if (file.name.endsWith(".zip")) {
Â  Â  Â  Â  Â  const zip = await JSZip.loadAsync(file);
Â  Â  Â  Â  Â  const entries = Object.values(zip.files).filter(f => !f.dir && /\.(png|jpe?g)$/i.test(f.name));
Â  Â  Â  Â  Â  for (const entry of entries) {
Â  Â  Â  Â  Â  Â  const blob = await entry.async("blob");
Â  Â  Â  Â  Â  Â  images.push(new File([blob], entry.name, { type: blob.type }));
Â  Â  Â  Â  Â  Â  loadedCount++;
Â  Â  Â  Â  Â  Â  uploadProgress.value = loadedCount / totalFiles; // Update for ZIP content
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (file.type.startsWith("image/")) {
Â  Â  Â  Â  Â  images.push(file);
Â  Â  Â  Â  Â  loadedCount++;
Â  Â  Â  Â  Â  uploadProgress.value = loadedCount / totalFiles;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return images.slice(0, 5000); // Limit to 5000 images
Â  Â  }

Â  Â  async function loadImage(file) {
Â  Â  Â  return new Promise(resolve => {
Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  img.onload = () => resolve(img);
Â  Â  Â  Â  img.src = URL.createObjectURL(file);
Â  Â  Â  });
Â  Â  }

Â  Â  function getLightDirection() {
Â  Â  Â  for (const radio of lightDirectionRadios) {
Â  Â  Â  Â  if (radio.checked) {
Â  Â  Â  Â  Â  switch (radio.value) {
Â  Â  Â  Â  Â  Â  case 'top-left': return [-0.5, -0.5, 1];
Â  Â  Â  Â  Â  Â  case 'top': return [0, -0.5, 1];
Â  Â  Â  Â  Â  Â  case 'top-right': return [0.5, -0.5, 1];
Â  Â  Â  Â  Â  Â  // Add more cases for other directions
Â  Â  Â  Â  Â  Â  default: return [0, 0, 1]; // Default to straight on
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return [0, 0, 1]; // Fallback
Â  Â  }

Â  Â  async function updatePreview() {
Â  Â  Â  if (!currentPreviewImage) return;

Â  Â  Â  const img = await loadImage(currentPreviewImage);
Â  Â  Â  const upscaledCanvas = upscale(img);

Â  Â  Â  // Original preview (pixelated, as requested)
Â  Â  Â  originalPreviewCtx.clearRect(0, 0, originalPreviewCanvas.width, originalPreviewCanvas.height);
Â  Â  Â  originalPreviewCtx.imageSmoothingEnabled = false;
Â  Â  Â  originalPreviewCtx.drawImage(upscaledCanvas, 0, 0, originalPreviewCanvas.width, originalPreviewCanvas.height);

Â  Â  Â  // Relief preview
Â  Â  Â  const reliefStrength = parseFloat(reliefPowerSlider.value);
Â  Â  Â  const normalMap = generateNormalMap(upscaledCanvas, reliefStrength);

Â  Â  Â  const lightDir = getLightDirection();
Â  Â  Â  const lightColor = hexToRgb(lightColorPicker.value);
Â  Â  Â  const lightTransparency = parseFloat(lightTransparencySlider.value);

Â  Â  Â  const litCanvas = applyLighting(upscaledCanvas, normalMap, lightDir, lightColor, lightTransparency);

Â  Â  Â  reliefPreviewCtx.clearRect(0, 0, reliefPreviewCanvas.width, reliefPreviewCanvas.height);
Â  Â  Â  reliefPreviewCtx.drawImage(litCanvas, 0, 0, reliefPreviewCanvas.width, reliefPreviewCanvas.width);
Â  Â  }

Â  Â  // Event Listeners for UI
Â  Â  input.onchange = () => {
Â  Â  Â  uploadBtn.disabled = input.files.length === 0;
Â  Â  Â  conversionControls.style.display = "none";
Â  Â  Â  btnOriginal.disabled = true;
Â  Â  Â  btnRelief.disabled = true;
Â  Â  Â  uploadProgress.style.display = "none";
Â  Â  Â  conversionProgress.style.display = "none";
Â  Â  };

Â  Â  uploadBtn.onclick = async () => {
Â  Â  Â  if (!input.files.length) return alert("Ajoute des images ou un zip !");

Â  Â  Â  uploadBtn.disabled = true;
Â  Â  Â  uploadProgress.style.display = "block";
Â  Â  Â  uploadProgress.value = 0;

Â  Â  Â  uploadedFiles = await extractFiles(input.files);

Â  Â  Â  if (uploadedFiles.length > 0) {
Â  Â  Â  Â  currentPreviewImage = uploadedFiles[Math.floor(Math.random() * uploadedFiles.length)];
Â  Â  Â  Â  updatePreview();
Â  Â  Â  Â  conversionControls.style.display = "block";
Â  Â  Â  } else {
Â  Â  Â  Â  alert("Aucune image valide trouvÃ©e dans la sÃ©lection.");
Â  Â  Â  Â  conversionControls.style.display = "none";
Â  Â  Â  }
Â  Â  Â  uploadProgress.style.display = "none";
Â  Â  };

Â  Â  reliefPowerSlider.oninput = updatePreview;
Â  Â  lightColorPicker.oninput = updatePreview;
Â  Â  lightTransparencySlider.oninput = updatePreview;
Â  Â  lightDirectionRadios.forEach(radio => radio.onchange = updatePreview);


Â  Â  startBtn.onclick = async () => {
Â  Â  Â  if (uploadedFiles.length === 0) return alert("Veuillez d'abord uploader des images.");
Â  Â  Â 
Â  Â  Â  startBtn.disabled = true;
Â  Â  Â  conversionProgress.style.display = "block";
Â  Â  Â  conversionProgress.value = 0;

Â  Â  Â  const zipOriginal = new JSZip();
Â  Â  Â  const zipRelief = new JSZip();

Â  Â  Â  const reliefStrength = parseFloat(reliefPowerSlider.value);
Â  Â  Â  const lightDir = getLightDirection();
Â  Â  Â  const lightColor = hexToRgb(lightColorPicker.value);
Â  Â  Â  const lightTransparency = parseFloat(lightTransparencySlider.value);

Â  Â  Â  for (let i = 0; i < uploadedFiles.length; i++) {
Â  Â  Â  Â  const file = uploadedFiles[i];
Â  Â  Â  Â  const img = await loadImage(file);
Â  Â  Â  Â  const name = file.name.replace(/\.\w+$/, "");
Â  Â  Â  Â  const canvas = upscale(img);

Â  Â  Â  Â  const normalMap = generateNormalMap(canvas, reliefStrength);
Â  Â  Â  Â  const litCanvas = applyLighting(canvas, normalMap, lightDir, lightColor, lightTransparency);

Â  Â  Â  Â  const blobOriginal = await new Promise(res => canvas.toBlob(res, "image/png"));
Â  Â  Â  Â  const blobRelief = await new Promise(res => litCanvas.toBlob(res, "image/png"));

Â  Â  Â  Â  zipOriginal.file(name + "_x4.png", blobOriginal);
Â  Â  Â  Â  zipRelief.file(name + "_relief.png", blobRelief);

Â  Â  Â  Â  conversionProgress.value = (i + 1) / uploadedFiles.length;
Â  Â  Â  }

Â  Â  Â  const zip1 = await zipOriginal.generateAsync({ type: "blob" });
Â  Â  Â  const zip2 = await zipRelief.generateAsync({ type: "blob" });

Â  Â  Â  btnOriginal.disabled = false;
Â  Â  Â  btnRelief.disabled = false;

Â  Â  Â  btnOriginal.onclick = () => {
Â  Â  Â  Â  const link = document.createElement("a");
Â  Â  Â  Â  link.href = URL.createObjectURL(zip1);
Â  Â  Â  Â  link.download = "images_agrandies.zip";
Â  Â  Â  Â  link.click();
Â  Â  Â  };

Â  Â  Â  btnRelief.onclick = () => {
Â  Â  Â  Â  const link = document.createElement("a");
Â  Â  Â  Â  link.href = URL.createObjectURL(zip2);
Â  Â  Â  Â  link.download = "images_relief.zip";
Â  Â  Â  Â  link.click();
Â  Â  Â  };

Â  Â  Â  setTimeout(() => conversionProgress.style.display = "none", 2000);
Â  Â  Â  startBtn.disabled = false;
Â  Â  };
Â  </script>
</body>
</html>
